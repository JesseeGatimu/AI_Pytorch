import torch
import torchvision
import torch.nn as nn
import torchvision.transforms as transforms

train_transform=transforms.Compose([
    transforms.RandomHorizontalFlip(),
    transforms.RandomCrop(32, padding=1),
    transforms.ToTensor(),
    transforms.Normalize((0.5,0.5,0.5),(0.5,0.5,0.5))
])
test_transform=transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.5,0.5,0.5),(0.5,0.5,0.5))
])
train_dataset=torchvision.datasets.CIFAR10(root='./root',download=True,train=True,transform=train_transform)
test_dataset=torchvision.datasets.CIFAR10(root='./root',download=True,train=False,transform=test_transform)
train_loader=torch.utils.data.DataLoader(train_dataset,batch_size=64,shuffle=True)
test_loader=torch.utils.data.DataLoader(test_dataset,batch_size=64,shuffle=False)

class CIFAR(nn.Module):
  def __init__(self):
    super(CIFAR,self).__init__()
    self.conv1=nn.Conv2d(3,32,kernel_size=3,padding=1)
    self.pool=nn.MaxPool2d(2,2)
    self.conv2=nn.Conv2d(32,64,kernel_size=3,padding=1)
    self.conv3 = nn.Conv2d(64, 128, kernel_size=3, padding=1)
    self.relu=nn.ReLU()
    #fully connected layers
    self.fc1=nn.Linear(128*4*4,256)
    self.fc2=nn.Linear(256,10)

  def forward(self,x):
    x=self.conv1(x)
    x=self.relu(x)
    x=self.pool(x)
    x=self.conv2(x)
    x=self.relu(x)
    x=self.pool(x)
    x=self.conv3(x)
    x=self.relu(x)
    x=self.pool(x)
    x=x.view(-1,128*4*4)
    x=self.fc1(x)
    x=self.relu(x)
    x=self.fc2(x)
    return x

model=CIFAR()
criterion=nn.CrossEntropyLoss()
optimizer=torch.optim.Adam(model.parameters(),lr=0.001)
epochs=5O

# Training Loop
for epoch in range(epochs):
  for images, labels in train_loader:
    outputs=model(images)
    loss=criterion(outputs,labels)
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()
  print(f"Epochs :: {epoch+1}/{epochs} , Loss :: {loss.item():.2f}")

# evaluation 
correct=0
total=0
with torch.no_grad():
  for images, labels in test_loader:
    outputs=model(images)
    _, predicted=torch.max(outputs,1)
    total+=labels.size(0)
    correct+=(predicted==labels).sum().item()
print(f"Accuracy :: {100*correct/total:.2f}%")
